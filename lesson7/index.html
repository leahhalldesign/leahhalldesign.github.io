<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 07</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <header>
        <nav>
            <ul id="nav">
                <li><a href="#" id="menu">&equiv; Menu</a></li>
                <li><a href="index.html">Home</a></li>
                <li><a href="lesson1/">Lesson 1</a></li>
                <li><a href="lesson2/">Lesson 2</a></li>
                <li><a href="lesson3/">Lesson 3</a></li>
                <li><a href="lesson4/">Lesson 4</a></li>
                <li><a href="lesson5/">Lesson 5</a></li>
                <li><a href="challenge-one/todo.html">Challenge 1</a></li>
                <li><a href="lesson7/">Lesson 7</a></li>
                <li><a href="lesson8/">Lesson 8</a></li>
                <li><a href="lesson9/">Lesson 9</a></li>
                <li><a href="lesson10/">Lesson 10</a></li>
                <li><a href="lesson11/auth/client/week11.html">Lesson 11</a></li>
           </ul>
        </nav>
        <h1>Lesson 07</h1>
    </header>
    <main>
        <h2>Notes</h2>     
        <h3>Further Functions</h3>
        <p>The call() method can be used to set the value of this inside a function to an object that is provided as the first argument.</p>
        <p>If a function doesn’t refer to an object as this in its body, it can still be called using the call() method, but you need provide null as its first argument.</p>
        <p>The apply() method works in the same way, except the arguments of the function are provided as an array, even if there is only one argument.</p>
        <p>There is no way to remove a variable from a scope once it’s been declared. If a variable is only required temporarily, it may cause confusion if it’s still available later in the code. Even worse, the name of the variable may clash with another piece of code (an external JavaScript library, for example) resulting in errors. Placing any code that uses the temporary variable inside an IIFE will ensure it’s only available while the IIFE is invoked, then it will disappear. </p>
        <p>This process requires the use of a temporary variable, called temp</p>
        <p>The recommended way to use strict mode is to place all your code inside an IIFE</p>
        <p>An IIFE can be used to enclose a block of code inside its own private scope so it doesn’t interfere with any other part of the program.</p>
        <p>Init-time branching enables the functions to work more effectively in the browser, and avoid checking for features every time they’re invoked.</p>
        <p>A recursive function is one that invokes itself until a certain condition is met.</p>
        <p>Callbacks can be used to facilitate event-driven asynchronous programming. Instead of waiting for an event to occur, a callback can be created that’s invoked when the event happens. This means that the code is able to run out of order, orasynchronously</p>
        <p>Callback hell is the term used to refer to this tangled mess of code</p>
        <p>Apromiserepresents the future result of an asynchronous operation. Promises don't do anything that can't already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can result from using multiple callbacks.</p>
        <p>When a promise is created, it calls an asynchronous operation and is then said to bepending. It remains in this state while the operation is taking place. At this stage, the promise is said to beunsettled. Once the operation has completed, the promise is said to have beensettled. A settled promise can result in two different outcomes:
                <li>Resolved ― the asynchronous operation was completed successfully.</li>
                <li>Rejected ― the asynchronous operation didn’t work as expected, wasn't successfully completed or resulted in an error.</li>
        </p>
        <p>Promises come into their own when multiple asynchronous tasks are required to be carried out one after the other. If each function that performs an asynchronous operation returns a promise, we can chain the then() methods together to form a sequential piece of code that’s easy to read. Each promise will only begin once the previous promise has been settled.</p>
        <p>A closure is a reference to a variable that was created inside the scope of another function, but is then kept alive and used in another part of the program.</p>
        <p>The outer() function only has access to the variable outside , which was declared in its scope. The inner() function, however, has access to the variable inside , declared in its scope, but also the variable outside , declared outside its scope, but from within the outer() function.</p>
        <p>A closure is formed when the inner function is returned by the outer function, maintaining access to any variables declared inside the enclosing function.</p>
        <p>Generators are special functions used to produce iterators that maintain the state of a value. To define a generator function, an asterisk symbol ( * ) is placed after the function declaration.</p>
        <p>A key aspect of functional programming is its use of pure functions. A pure function is a function that adheres to the following rules:
            <ol>
                <li> The return value of a pure function should only depend on the values provided as arguments. It doesn't rely on values from somewhere else in the program.</li>
                <li>There are no side-effects. A pure function doesn't change any values or data elsewhere in the program. It only makes non-destructive data transformations and returns new values, rather than altering any of the underlying data.</li>
                <li>Referential transparency. Given the same arguments, a pure function will always return the same result.</li>
            </ol>
        </p>
        <p>Higher-order functions are functions that accept another function as an argument, or return another function as a result, or both.</p>
        <p>Curryingis a process that involves the partial application of functions. A function is said to be curried when not all arguments have been supplied to the function, so it returns another function that retains the arguments already provided, and expects the remaining arguments that were omitted when the original function was called. A final result is only returned once all the expected arguments have eventually been provided.</p>
        <h3>Ajax</h3>
        <p>The Fetch API provides a global fetch() method that only has one mandatory argument, which is the URL of the resource you wish to fetch. </p>
        <p>The redirect() method can be used to redirect to another URL. It creates a new promise that resolves to the response from the redirected URL.</p>
        <p>The text() method takes a stream of text from the response, reads it to completion and then returns a promise that resolves to a USVSting object that can be treated as a string in JavaScript.</p>
        <p>The blob() method is used to read a file of raw data, such as an image or a spreadsheet. Once it has read the whole file, it returns a promise that resolves with a blob object.</p>
        <p>We can get more fine-grained control over the request being made by providing a Request object as an argument. This allows a number of options to be set about the request.</p>
        <p>The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax. A FormData instance is created using a constructor function.</p>



        <h2>Code Examples</h2>
        <h3>Temporary Variable</h3>
        <code>let a = 1;
            let b = 2;
            (()=>{
                const temp = a;
                a = b;
                b = temp;
            })();
            a;
            << 2
            b;
            << 1
            console.log(temp);
            << Error: "temp is not defined"</code>
        <h3>Init-Time Branching</h3>
        <code>function ride(){
            if (window.unicorn) { 
                ride = function(){
                // some code that uses the brand new and sparkly unicorn methods
                return 'Riding on a unicorn is the best!';
                }
            } else {
                ride = function(){
                // some code that uses the older pony methods
                return 'Riding on a pony is still pretty good';
                }
            }
            return ride();
        }</code>
        <h3>Recursive Functions</h3>
        <code>function factorial(n) {
            if (n === 0) {
                return 1;
            } else {
                return n * factorial(n - 1);
            }
        }</code>
        <h3>Asynchronous Programming</h3>
        <code>function wait(message, callback, seconds){
            setTimeout(callback,seconds * 1000);
            console.log(message);
        }</code>
        <h3>Creating A Promise</h3>
        <code>const promise = new Promise( (resolve, reject) => {
            // initialization code goes here
            if (success) {
                resolve(value);
            } else {
                reject(error);
            }
        });</code>
        <h3>Chaining Promises</h3>
        <code>login(userName)
            .then(user => getPlayerInfo(user.id))
            .then(info => loadGame(info))
            .catch( throw error)</code>
        <h3>Pure Function</h3>
        <code>function reverse(string) {
            return string.split('').reverse().join('');
        }</code>
        <h3>Fetch API</h3>
        <code>fetch(url)
            .then( response => response.redirect(newURL)); // redirects to another URL
            .then( // do something else )
            .catch( error => console.log('There was an error: ', error))</code>




        <h2>Team Activity</h2>
        <a href="team.html">Lesson 07 Team Activity</a>
    </main>
    <footer>
        &copy; 2020 | Portfolio | Leah Hall
    </footer>
    <script src="scripts/main.js"></script>
</body>
</html>